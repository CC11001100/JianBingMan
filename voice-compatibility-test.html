<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èªéŸ³å…¼å®¹æ€§æ¸¬è©¦ - ç…é¤…ä¿ </title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .test-button {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .test-button:hover {
            background: #e55722;
        }
        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .result-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .success {
            background-color: #e8f5e8;
            border-color: #4caf50;
        }
        .error {
            background-color: #ffebee;
            border-color: #f44336;
        }
        .warning {
            background-color: #fff3e0;
            border-color: #ff9800;
        }
        .info {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }
        .loading {
            text-align: center;
            padding: 40px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff6b35;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .test-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 6px;
        }
        .test-item .icon {
            margin-right: 10px;
            font-size: 20px;
        }
        .test-details {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        .recommendations {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .recommendations h3 {
            margin-top: 0;
            color: #1976d2;
        }
        .recommendations ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .recommendations li {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¥ ç…é¤…ä¿  - èªéŸ³å…¼å®¹æ€§æ¸¬è©¦</h1>
            <p>æª¢æ¸¬ç•¶å‰ç€è¦½å™¨å’Œè¨­å‚™å°èªéŸ³åŠŸèƒ½çš„æ”¯æŒç¨‹åº¦</p>
        </div>

        <button id="testButton" class="test-button">é–‹å§‹å…¼å®¹æ€§æ¸¬è©¦</button>
        
        <div id="loadingSection" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>æ­£åœ¨é€²è¡Œå…¼å®¹æ€§æ¸¬è©¦ï¼Œè«‹ç¨å€™...</p>
        </div>
        
        <div id="resultSection" style="display: none;">
            <!-- æ¸¬è©¦çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º -->
        </div>
    </div>

    <script>
        // ç€è¦½å™¨æª¢æ¸¬
        function getBrowserInfo() {
            const userAgent = navigator.userAgent;
            let name = 'Unknown';
            let version = 'Unknown';
            let engine = 'Unknown';
            
            if (userAgent.includes('Chrome')) {
                name = 'Chrome';
                const match = userAgent.match(/Chrome\/([0-9.]+)/);
                version = match ? match[1] : 'Unknown';
                engine = 'Blink';
            } else if (userAgent.includes('Firefox')) {
                name = 'Firefox';
                const match = userAgent.match(/Firefox\/([0-9.]+)/);
                version = match ? match[1] : 'Unknown';
                engine = 'Gecko';
            } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                name = 'Safari';
                const match = userAgent.match(/Version\/([0-9.]+)/);
                version = match ? match[1] : 'Unknown';
                engine = 'WebKit';
            } else if (userAgent.includes('Edge')) {
                name = 'Edge';
                const match = userAgent.match(/Edge\/([0-9.]+)/);
                version = match ? match[1] : 'Unknown';
                engine = 'EdgeHTML';
            } else if (userAgent.includes('Edg')) {
                name = 'Edge (Chromium)';
                const match = userAgent.match(/Edg\/([0-9.]+)/);
                version = match ? match[1] : 'Unknown';
                engine = 'Blink';
            }

            let os = 'Unknown';
            if (userAgent.includes('Windows')) os = 'Windows';
            else if (userAgent.includes('Mac')) os = 'macOS';
            else if (userAgent.includes('Linux')) os = 'Linux';
            else if (userAgent.includes('Android')) os = 'Android';
            else if (userAgent.includes('iOS')) os = 'iOS';

            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);

            return { name, version, engine, os, isMobile };
        }

        // Web Speech API æ¸¬è©¦
        async function testWebSpeechApi() {
            try {
                const supported = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
                
                if (!supported) {
                    return {
                        success: false,
                        message: 'Web Speech API ä¸æ”¯æŒ',
                        details: {
                            speechSynthesis: 'speechSynthesis' in window,
                            speechSynthesisUtterance: 'SpeechSynthesisUtterance' in window
                        }
                    };
                }

                // æ¸¬è©¦èªéŸ³åˆæˆåŠŸèƒ½
                return new Promise((resolve) => {
                    const utterance = new SpeechSynthesisUtterance('æ¸¬è©¦');
                    utterance.volume = 0; // éœéŸ³æ¸¬è©¦
                    
                    const timeout = setTimeout(() => {
                        resolve({
                            success: false,
                            message: 'Web Speech API éŸ¿æ‡‰è¶…æ™‚',
                            error: 'èªéŸ³åˆæˆåˆå§‹åŒ–è¶…é5ç§’'
                        });
                    }, 5000);

                    utterance.onstart = () => {
                        clearTimeout(timeout);
                        speechSynthesis.cancel();
                        resolve({
                            success: true,
                            message: 'Web Speech API å®Œå…¨æ”¯æŒ',
                            details: {
                                voicesCount: speechSynthesis.getVoices().length,
                                speaking: speechSynthesis.speaking,
                                pending: speechSynthesis.pending,
                                paused: speechSynthesis.paused
                            }
                        });
                    };

                    utterance.onerror = (event) => {
                        clearTimeout(timeout);
                        resolve({
                            success: false,
                            message: 'Web Speech API éŒ¯èª¤',
                            error: event.error
                        });
                    };

                    speechSynthesis.speak(utterance);
                });
            } catch (error) {
                return {
                    success: false,
                    message: 'Web Speech API æ¸¬è©¦å¤±æ•—',
                    error: error.message
                };
            }
        }

        // MediaRecorder API æ¸¬è©¦
        async function testMediaRecorderApi() {
            try {
                const supported = 'MediaRecorder' in window && 'mediaDevices' in navigator;

                if (!supported) {
                    return {
                        success: false,
                        message: 'MediaRecorder API ä¸æ”¯æŒ',
                        details: {
                            mediaRecorder: 'MediaRecorder' in window,
                            mediaDevices: 'mediaDevices' in navigator,
                            getUserMedia: navigator.mediaDevices && 'getUserMedia' in navigator.mediaDevices
                        }
                    };
                }

                const supportedTypes = [
                    'audio/webm',
                    'audio/webm;codecs=opus',
                    'audio/ogg',
                    'audio/mp4',
                    'audio/wav'
                ].filter(type => MediaRecorder.isTypeSupported(type));

                if (supportedTypes.length === 0) {
                    return {
                        success: false,
                        message: 'MediaRecorder API ä¸æ”¯æŒä»»ä½•éŸ³é »æ ¼å¼',
                        details: { supportedTypes }
                    };
                }

                return {
                    success: true,
                    message: 'MediaRecorder API å®Œå…¨æ”¯æŒ',
                    details: {
                        supportedTypes,
                        preferredType: supportedTypes[0]
                    }
                };
            } catch (error) {
                return {
                    success: false,
                    message: 'MediaRecorder API æ¸¬è©¦å¤±æ•—',
                    error: error.message
                };
            }
        }

        // Web Audio API æ¸¬è©¦
        async function testWebAudioApi() {
            try {
                const supported = 'AudioContext' in window || 'webkitAudioContext' in window;

                if (!supported) {
                    return {
                        success: false,
                        message: 'Web Audio API ä¸æ”¯æŒ'
                    };
                }

                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContextClass();

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                gainNode.gain.value = 0;
                oscillator.frequency.value = 440;
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);

                const result = {
                    success: true,
                    message: 'Web Audio API å®Œå…¨æ”¯æŒ',
                    details: {
                        sampleRate: audioContext.sampleRate,
                        state: audioContext.state,
                        maxChannelCount: audioContext.destination.maxChannelCount
                    }
                };

                await audioContext.close();
                return result;
            } catch (error) {
                return {
                    success: false,
                    message: 'Web Audio API æ¸¬è©¦å¤±æ•—',
                    error: error.message
                };
            }
        }

        // èªéŸ³åˆ—è¡¨æ¸¬è©¦
        async function testVoicesAndLanguage() {
            try {
                if (!('speechSynthesis' in window)) {
                    return {
                        success: false,
                        message: 'ç„¡æ³•æ¸¬è©¦èªéŸ³åˆ—è¡¨ï¼šSpeech Synthesis ä¸æ”¯æŒ'
                    };
                }

                let voices = speechSynthesis.getVoices();
                
                if (voices.length === 0) {
                    await new Promise((resolve) => {
                        const timeout = setTimeout(resolve, 2000);
                        speechSynthesis.onvoiceschanged = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                    });
                }

                voices = speechSynthesis.getVoices();
                
                const chineseVoices = voices.filter(voice => 
                    voice.lang.includes('zh') || 
                    voice.lang.includes('cmn') ||
                    voice.name.includes('Chinese') ||
                    voice.name.includes('ä¸­æ–‡')
                );

                const languageSupport = {
                    totalVoices: voices.length,
                    chineseVoices: chineseVoices.length,
                    languages: [...new Set(voices.map(v => v.lang))],
                    localVoices: voices.filter(v => v.localService).length,
                    remoteVoices: voices.filter(v => !v.localService).length
                };

                if (voices.length === 0) {
                    return {
                        success: false,
                        message: 'æ²’æœ‰å¯ç”¨çš„èªéŸ³',
                        details: languageSupport
                    };
                }

                return {
                    success: true,
                    message: `æ‰¾åˆ° ${voices.length} å€‹èªéŸ³ï¼Œå…¶ä¸­ ${chineseVoices.length} å€‹ä¸­æ–‡èªéŸ³`,
                    details: languageSupport
                };
            } catch (error) {
                return {
                    success: false,
                    message: 'èªéŸ³åˆ—è¡¨æ¸¬è©¦å¤±æ•—',
                    error: error.message
                };
            }
        }

        // å‚™ç”¨æ©Ÿåˆ¶æ¸¬è©¦
        async function testFallbackMechanisms() {
            try {
                const fallbackTests = [];

                const vibrationSupported = 'vibrate' in navigator;
                fallbackTests.push({
                    mechanism: 'æŒ¯å‹•æé†’',
                    supported: vibrationSupported,
                    description: vibrationSupported ? 'æ”¯æŒæŒ¯å‹•API' : 'ä¸æ”¯æŒæŒ¯å‹•API'
                });

                const notificationSupported = 'Notification' in window;
                fallbackTests.push({
                    mechanism: 'æ¡Œé¢é€šçŸ¥',
                    supported: notificationSupported,
                    description: notificationSupported ? 'æ”¯æŒæ¡Œé¢é€šçŸ¥' : 'ä¸æ”¯æŒæ¡Œé¢é€šçŸ¥'
                });

                const visibilitySupported = 'visibilityState' in document;
                fallbackTests.push({
                    mechanism: 'é é¢å¯è¦‹æ€§æª¢æ¸¬',
                    supported: visibilitySupported,
                    description: visibilitySupported ? 'æ”¯æŒé é¢å¯è¦‹æ€§API' : 'ä¸æ”¯æŒé é¢å¯è¦‹æ€§API'
                });

                const wakeLockSupported = 'wakeLock' in navigator;
                fallbackTests.push({
                    mechanism: 'å±å¹•å¸¸äº®',
                    supported: wakeLockSupported,
                    description: wakeLockSupported ? 'æ”¯æŒWake Lock API' : 'ä¸æ”¯æŒWake Lock API'
                });

                const supportedCount = fallbackTests.filter(test => test.supported).length;

                return {
                    success: supportedCount > 0,
                    message: `${supportedCount}/${fallbackTests.length} å€‹å‚™ç”¨æ©Ÿåˆ¶å¯ç”¨`,
                    details: fallbackTests
                };
            } catch (error) {
                return {
                    success: false,
                    message: 'å‚™ç”¨æ©Ÿåˆ¶æ¸¬è©¦å¤±æ•—',
                    error: error.message
                };
            }
        }

        // è©•ä¼°æ•´é«”å…¼å®¹æ€§
        function evaluateCompatibility(results) {
            const recommendations = [];
            let score = 0;

            if (results.webSpeechApi.success) score += 30;
            else recommendations.push('ç€è¦½å™¨ä¸æ”¯æŒWeb Speech APIï¼Œå»ºè­°ä½¿ç”¨Chromeã€Firefoxæˆ–Safariæœ€æ–°ç‰ˆæœ¬');

            if (results.mediaRecorderApi.success) score += 20;
            else recommendations.push('ç€è¦½å™¨ä¸æ”¯æŒMediaRecorder APIï¼Œç„¡æ³•éŒ„è£½è‡ªå®šç¾©èªéŸ³');

            if (results.webAudioApi.success) score += 20;
            else recommendations.push('ç€è¦½å™¨ä¸æ”¯æŒWeb Audio APIï¼ŒéŸ³æ•ˆåŠŸèƒ½å¯èƒ½å—é™');

            if (results.voicesList.success) score += 15;
            else recommendations.push('æ²’æœ‰å¯ç”¨çš„èªéŸ³ï¼ŒèªéŸ³æé†’åŠŸèƒ½å°‡ä¸å¯ç”¨');

            if (results.fallbackMechanisms.success) score += 15;
            else recommendations.push('å‚™ç”¨æé†’æ©Ÿåˆ¶ä¸è¶³ï¼Œå»ºè­°åœ¨æ”¯æŒå®Œæ•´åŠŸèƒ½çš„è¨­å‚™ä¸Šä½¿ç”¨');

            let rating;
            if (score >= 80) rating = 'excellent';
            else if (score >= 60) rating = 'good';
            else if (score >= 30) rating = 'limited';
            else rating = 'poor';

            return { rating, recommendations, score };
        }

        // æ¸²æŸ“æ¸¬è©¦çµæœ
        function renderResults(results, browserInfo, evaluation) {
            const resultSection = document.getElementById('resultSection');
            
            const getCompatibilityClass = (rating) => {
                switch (rating) {
                    case 'excellent': return 'success';
                    case 'good': return 'info';
                    case 'limited': return 'warning';
                    case 'poor': return 'error';
                    default: return '';
                }
            };

            const getCompatibilityText = (rating) => {
                switch (rating) {
                    case 'excellent': return 'å„ªç§€ - æ‰€æœ‰åŠŸèƒ½å®Œå…¨æ”¯æŒ';
                    case 'good': return 'è‰¯å¥½ - å¤§éƒ¨åˆ†åŠŸèƒ½æ”¯æŒ';
                    case 'limited': return 'æœ‰é™ - éƒ¨åˆ†åŠŸèƒ½æ”¯æŒ';
                    case 'poor': return 'è¼ƒå·® - åŠŸèƒ½æ”¯æŒä¸è¶³';
                    default: return 'æœªçŸ¥';
                }
            };

            const renderTestItem = (title, result, icon) => {
                const success = result?.success;
                const message = result?.message || 'æœªæ¸¬è©¦';
                const iconHtml = success ? 'âœ…' : 'âŒ';
                
                let detailsHtml = '';
                if (result?.details) {
                    detailsHtml = `<div class="test-details">${JSON.stringify(result.details, null, 2)}</div>`;
                }
                
                return `
                    <div class="test-item ${success ? 'success' : 'error'}">
                        <div class="icon">${iconHtml}</div>
                        <div>
                            <strong>${icon} ${title}</strong><br>
                            <span>${message}</span>
                            ${detailsHtml}
                        </div>
                    </div>
                `;
            };

            let recommendationsHtml = '';
            if (evaluation.recommendations.length > 0) {
                recommendationsHtml = `
                    <div class="recommendations">
                        <h3>ğŸ”§ å„ªåŒ–å»ºè­°</h3>
                        <ul>
                            ${evaluation.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            resultSection.innerHTML = `
                <h2>ğŸ“Š æ¸¬è©¦çµæœ</h2>
                
                <div class="result-section info">
                    <h3>ğŸ’» è¨­å‚™ä¿¡æ¯</h3>
                    <p><strong>ç€è¦½å™¨:</strong> ${browserInfo.name} ${browserInfo.version} (${browserInfo.engine})</p>
                    <p><strong>æ“ä½œç³»çµ±:</strong> ${browserInfo.os}</p>
                    <p><strong>è¨­å‚™é¡å‹:</strong> ${browserInfo.isMobile ? 'ç§»å‹•è¨­å‚™' : 'æ¡Œé¢è¨­å‚™'}</p>
                </div>

                <div class="result-section ${getCompatibilityClass(evaluation.rating)}">
                    <h3>ğŸ† æ•´é«”å…¼å®¹æ€§è©•ç´š</h3>
                    <p style="font-size: 1.2em; font-weight: bold;">
                        ${getCompatibilityText(evaluation.rating)} (å¾—åˆ†: ${evaluation.score}/100)
                    </p>
                </div>

                <div class="result-section">
                    <h3>ğŸ” åŠŸèƒ½æ”¯æŒè©³æƒ…</h3>
                    ${renderTestItem('Web Speech API', results.webSpeechApi, 'ğŸ—£ï¸')}
                    ${renderTestItem('MediaRecorder API', results.mediaRecorderApi, 'ğŸ¤')}
                    ${renderTestItem('Web Audio API', results.webAudioApi, 'ğŸ”Š')}
                    ${renderTestItem('èªéŸ³åˆ—è¡¨', results.voicesList, 'ğŸŒ')}
                    ${renderTestItem('å‚™ç”¨æ©Ÿåˆ¶', results.fallbackMechanisms, 'ğŸ”„')}
                </div>

                ${recommendationsHtml}
            `;
            
            resultSection.style.display = 'block';
        }

        // é‹è¡Œå®Œæ•´æ¸¬è©¦
        async function runCompleteTest() {
            const testButton = document.getElementById('testButton');
            const loadingSection = document.getElementById('loadingSection');
            const resultSection = document.getElementById('resultSection');
            
            testButton.disabled = true;
            loadingSection.style.display = 'block';
            resultSection.style.display = 'none';

            try {
                console.log('é–‹å§‹åŸ·è¡ŒèªéŸ³å…¼å®¹æ€§æ¸¬è©¦...');
                
                const browserInfo = getBrowserInfo();
                
                const [
                    webSpeechResult,
                    mediaRecorderResult,
                    webAudioResult,
                    voicesResult,
                    fallbackResult
                ] = await Promise.all([
                    testWebSpeechApi(),
                    testMediaRecorderApi(),
                    testWebAudioApi(),
                    testVoicesAndLanguage(),
                    testFallbackMechanisms()
                ]);

                const results = {
                    webSpeechApi: webSpeechResult,
                    mediaRecorderApi: mediaRecorderResult,
                    webAudioApi: webAudioResult,
                    voicesList: voicesResult,
                    fallbackMechanisms: fallbackResult
                };

                const evaluation = evaluateCompatibility(results);
                
                console.log('èªéŸ³å…¼å®¹æ€§æ¸¬è©¦å®Œæˆ', { results, browserInfo, evaluation });
                
                renderResults(results, browserInfo, evaluation);

            } catch (error) {
                console.error('èªéŸ³å…¼å®¹æ€§æ¸¬è©¦åŸ·è¡Œå¤±æ•—:', error);
                resultSection.innerHTML = `
                    <div class="result-section error">
                        <h3>âŒ æ¸¬è©¦å¤±æ•—</h3>
                        <p>æ¸¬è©¦åŸ·è¡Œéç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: ${error.message}</p>
                    </div>
                `;
                resultSection.style.display = 'block';
            } finally {
                loadingSection.style.display = 'none';
                testButton.disabled = false;
                testButton.textContent = 'é‡æ–°æ¸¬è©¦';
            }
        }

        // äº‹ä»¶ç›£è½å™¨
        document.getElementById('testButton').addEventListener('click', runCompleteTest);

        // é é¢åŠ è¼‰å®Œæˆå¾Œè‡ªå‹•é‹è¡Œæ¸¬è©¦
        window.addEventListener('load', runCompleteTest);
    </script>
</body>
</html>


