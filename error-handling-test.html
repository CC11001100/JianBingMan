<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŒ¯èª¤è™•ç†å’Œç•°å¸¸å ´æ™¯æ¸¬è©¦ - ç…é¤…ä¿ </title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: #ff6b35;
            color: white;
        }
        .btn-primary:hover {
            background: #e55722;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .test-category {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ddd;
        }
        .test-category.storage {
            background-color: #e3f2fd;
            border-left-color: #2196f3;
        }
        .test-category.network {
            background-color: #e8f5e8;
            border-left-color: #4caf50;
        }
        .test-category.permission {
            background-color: #fff3e0;
            border-left-color: #ff9800;
        }
        .test-category.api {
            background-color: #f3e5f5;
            border-left-color: #9c27b0;
        }
        .test-category.runtime {
            background-color: #ffebee;
            border-left-color: #f44336;
        }
        .test-item {
            margin: 10px 0;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            background: white;
        }
        .test-item.passed {
            border-left: 4px solid #4caf50;
            background-color: #e8f5e8;
        }
        .test-item.failed {
            border-left: 4px solid #f44336;
            background-color: #ffebee;
        }
        .test-name {
            font-weight: 600;
            margin-bottom: 5px;
        }
        .test-message {
            color: #666;
            font-size: 14px;
            margin-bottom: 5px;
        }
        .test-guidance {
            color: #888;
            font-size: 12px;
            font-style: italic;
        }
        .test-details {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .stability-indicator {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            color: white;
        }
        .stability-excellent {
            background: #4caf50;
        }
        .stability-good {
            background: #2196f3;
        }
        .stability-fair {
            background: #ff9800;
        }
        .stability-poor {
            background: #f44336;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        .recommendations {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .recommendations h3 {
            margin-top: 0;
            color: #1976d2;
        }
        .recommendations ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .recommendations li {
            margin: 8px 0;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ff6b35;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .alert {
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
        }
        .alert-error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }
        .alert-success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        .browser-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 14px;
        }
        .error-patterns {
            margin: 20px 0;
        }
        .pattern-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #ddd;
        }
        .pattern-item.severity-high {
            border-left-color: #f44336;
        }
        .pattern-item.severity-medium {
            border-left-color: #ff9800;
        }
        .pattern-item.severity-low {
            border-left-color: #4caf50;
        }
        .badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        .badge-success {
            background: #d4edda;
            color: #155724;
        }
        .badge-warning {
            background: #fff3cd;
            color: #856404;
        }
        .badge-danger {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ›¡ï¸ ç…é¤…ä¿  - éŒ¯èª¤è™•ç†å’Œç•°å¸¸å ´æ™¯æ¸¬è©¦</h1>
            <p>é©—è­‰æ‡‰ç”¨åœ¨å„ç¨®éŒ¯èª¤å’Œç•°å¸¸å ´æ™¯ä¸‹çš„è™•ç†èƒ½åŠ›å’Œç©©å®šæ€§</p>
        </div>

        <div class="control-panel">
            <button id="runTestBtn" class="btn btn-primary">é‹è¡Œå®Œæ•´éŒ¯èª¤æ¸¬è©¦</button>
            <button id="testStorageBtn" class="btn btn-secondary">å­˜å„²éŒ¯èª¤æ¸¬è©¦</button>
            <button id="testNetworkBtn" class="btn btn-secondary">ç¶²çµ¡éŒ¯èª¤æ¸¬è©¦</button>
            <button id="testPermissionBtn" class="btn btn-secondary">æ¬Šé™éŒ¯èª¤æ¸¬è©¦</button>
            <button id="testApiBtn" class="btn btn-secondary">APIéŒ¯èª¤æ¸¬è©¦</button>
            <button id="clearBtn" class="btn btn-danger">æ¸…é™¤çµæœ</button>
        </div>

        <div id="errorAlert" class="alert alert-error" style="display: none;"></div>
        <div id="successAlert" class="alert alert-success" style="display: none;"></div>

        <div id="testResults" class="test-section" style="display: none;">
            <h3>æ¸¬è©¦çµæœ</h3>
            <div id="overallStats" class="stats-grid"></div>
            <div id="stabilityIndicator" style="text-align: center; margin: 20px 0;"></div>
            <div id="testCategories"></div>
        </div>

        <div id="browserInfo" class="browser-info" style="display: none;">
            <h4>ç€è¦½å™¨ä¿¡æ¯</h4>
            <div id="browserDetails"></div>
        </div>

        <div id="recommendations" class="recommendations" style="display: none;">
            <h3>ğŸ”§ å„ªåŒ–å»ºè­°</h3>
            <ul id="recommendationsList"></ul>
        </div>

        <div id="errorPatterns" class="error-patterns" style="display: none;">
            <h3>ğŸ“Š éŒ¯èª¤æ¨¡å¼åˆ†æ</h3>
            <div id="patternsContainer"></div>
        </div>
    </div>

    <script>
        // æ¨¡æ“¬éŒ¯èª¤è™•ç†æ¸¬è©¦å™¨
        class ErrorHandlingTester {
            constructor() {
                this.testResults = [];
            }

            async runCompleteErrorTest() {
                console.log('é–‹å§‹éŒ¯èª¤è™•ç†å’Œç•°å¸¸å ´æ™¯æ¸¬è©¦...');
                this.testResults = [];

                // ä¸¦è¡ŒåŸ·è¡Œä¸åŒé¡åˆ¥çš„æ¸¬è©¦
                await Promise.all([
                    this.testStorageErrors(),
                    this.testNetworkErrors(),
                    this.testPermissionErrors(),
                    this.testApiErrors(),
                    this.testRuntimeErrors()
                ]);

                return this.generateTestReport();
            }

            async testStorageErrors() {
                console.log('æ¸¬è©¦å­˜å„²éŒ¯èª¤è™•ç†...');

                // æ¸¬è©¦ IndexedDB æ”¯æŒ
                try {
                    const supported = 'indexedDB' in window;
                    this.testResults.push({
                        testName: 'IndexedDB æ”¯æŒæª¢æ¸¬',
                        category: 'storage',
                        success: supported,
                        message: supported ? 'IndexedDB å¯ç”¨' : 'IndexedDB ä¸æ”¯æŒ',
                        userGuidance: supported ? 'å­˜å„²åŠŸèƒ½æ­£å¸¸' : 'å­˜å„²åŠŸèƒ½å—é™ï¼Œè«‹ä½¿ç”¨ç¾ä»£ç€è¦½å™¨'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'IndexedDB æ”¯æŒæª¢æ¸¬',
                        category: 'storage',
                        success: false,
                        message: 'IndexedDB æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦å­˜å„²é…é¡
                try {
                    if ('storage' in navigator && 'estimate' in navigator.storage) {
                        const quota = await navigator.storage.estimate();
                        const usedMB = Math.round((quota.usage || 0) / 1024 / 1024);
                        const totalMB = Math.round((quota.quota || 0) / 1024 / 1024);
                        
                        this.testResults.push({
                            testName: 'å­˜å„²é…é¡æª¢æ¸¬',
                            category: 'storage',
                            success: true,
                            message: `å·²ä½¿ç”¨: ${usedMB}MB / ${totalMB}MB`,
                            userGuidance: 'å­˜å„²ç©ºé–“å……è¶³'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'å­˜å„²é…é¡æª¢æ¸¬',
                            category: 'storage',
                            success: false,
                            message: 'ç„¡æ³•ç²å–å­˜å„²é…é¡ä¿¡æ¯',
                            userGuidance: 'ç„¡æ³•æª¢æ¸¬å­˜å„²ç©ºé–“ï¼Œå»ºè­°å®šæœŸæ¸…ç†ç€è¦½å™¨æ•¸æ“š'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'å­˜å„²é…é¡æª¢æ¸¬',
                        category: 'storage',
                        success: false,
                        message: 'å­˜å„²é…é¡æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦ localStorage
                try {
                    const testKey = 'error_test_' + Date.now();
                    localStorage.setItem(testKey, 'test');
                    const value = localStorage.getItem(testKey);
                    localStorage.removeItem(testKey);
                    
                    this.testResults.push({
                        testName: 'localStorage åŠŸèƒ½æ¸¬è©¦',
                        category: 'storage',
                        success: value === 'test',
                        message: value === 'test' ? 'localStorage å·¥ä½œæ­£å¸¸' : 'localStorage è®€å¯«ç•°å¸¸',
                        userGuidance: 'localStorage å¯ç”¨æ–¼å­˜å„²è‡¨æ™‚æ•¸æ“š'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'localStorage åŠŸèƒ½æ¸¬è©¦',
                        category: 'storage',
                        success: false,
                        message: 'localStorage ä¸å¯ç”¨',
                        errorDetails: error.message,
                        userGuidance: 'ç€è¦½å™¨éš±ç§æ¨¡å¼å¯èƒ½ç¦ç”¨äº† localStorage'
                    });
                }
            }

            async testNetworkErrors() {
                console.log('æ¸¬è©¦ç¶²çµ¡éŒ¯èª¤è™•ç†...');

                // æ¸¬è©¦åœ¨ç·šç‹€æ…‹
                try {
                    const isOnline = navigator.onLine;
                    this.testResults.push({
                        testName: 'ç¶²çµ¡é€£æ¥ç‹€æ…‹',
                        category: 'network',
                        success: true,
                        message: `ç•¶å‰ç‹€æ…‹: ${isOnline ? 'åœ¨ç·š' : 'é›¢ç·š'}`,
                        fallbackActivated: !isOnline,
                        userGuidance: isOnline ? 'ç¶²çµ¡é€£æ¥æ­£å¸¸' : 'ç•¶å‰é›¢ç·šï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—é™'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'ç¶²çµ¡é€£æ¥ç‹€æ…‹',
                        category: 'network',
                        success: false,
                        message: 'ç„¡æ³•æª¢æ¸¬ç¶²çµ¡ç‹€æ…‹',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦ç¶²çµ¡é¡å‹æª¢æ¸¬
                try {
                    if ('connection' in navigator) {
                        const connection = navigator.connection;
                        const effectiveType = connection.effectiveType || 'unknown';
                        const downlink = connection.downlink || 0;
                        
                        this.testResults.push({
                            testName: 'ç¶²çµ¡é¡å‹æª¢æ¸¬',
                            category: 'network',
                            success: true,
                            message: `ç¶²çµ¡é¡å‹: ${effectiveType}, ä¸‹è¡Œé€Ÿåº¦: ${downlink}Mbps`,
                            fallbackActivated: effectiveType === '2g' || effectiveType === 'slow-2g',
                            userGuidance: effectiveType === '2g' ? 'ç¶²çµ¡è¼ƒæ…¢ï¼Œå»ºè­°ä½¿ç”¨åŸºæœ¬åŠŸèƒ½' : 'ç¶²çµ¡é€Ÿåº¦è‰¯å¥½'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'ç¶²çµ¡é¡å‹æª¢æ¸¬',
                            category: 'network',
                            success: false,
                            message: 'ä¸æ”¯æŒç¶²çµ¡é¡å‹æª¢æ¸¬',
                            userGuidance: 'ç„¡æ³•æª¢æ¸¬ç¶²çµ¡é¡å‹ï¼ŒåŠŸèƒ½æŒ‰æ­£å¸¸ç¶²çµ¡é‹è¡Œ'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'ç¶²çµ¡é¡å‹æª¢æ¸¬',
                        category: 'network',
                        success: false,
                        message: 'ç¶²çµ¡é¡å‹æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦é é¢å¯è¦‹æ€§ API
                try {
                    const supported = 'visibilityState' in document;
                    const currentState = supported ? document.visibilityState : 'unknown';
                    
                    this.testResults.push({
                        testName: 'é é¢å¯è¦‹æ€§æª¢æ¸¬',
                        category: 'network',
                        success: supported,
                        message: supported ? `ç•¶å‰ç‹€æ…‹: ${currentState}` : 'ä¸æ”¯æŒé é¢å¯è¦‹æ€§æª¢æ¸¬',
                        userGuidance: supported ? 'æ”¯æŒå¾Œå°å„ªåŒ–' : 'ç„¡æ³•æª¢æ¸¬é é¢ç‹€æ…‹'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'é é¢å¯è¦‹æ€§æª¢æ¸¬',
                        category: 'network',
                        success: false,
                        message: 'é é¢å¯è¦‹æ€§æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }
            }

            async testPermissionErrors() {
                console.log('æ¸¬è©¦æ¬Šé™éŒ¯èª¤è™•ç†...');

                // æ¸¬è©¦é€šçŸ¥æ¬Šé™
                try {
                    if ('Notification' in window) {
                        const permission = Notification.permission;
                        this.testResults.push({
                            testName: 'é€šçŸ¥æ¬Šé™æª¢æ¸¬',
                            category: 'permission',
                            success: true,
                            message: `é€šçŸ¥æ¬Šé™: ${permission}`,
                            fallbackActivated: permission === 'denied',
                            userGuidance: permission === 'granted' ? 'å¯ä»¥ç™¼é€æ¡Œé¢é€šçŸ¥' : 
                                        permission === 'denied' ? 'é€šçŸ¥å·²è¢«é˜»æ­¢ï¼Œä½¿ç”¨å…¶ä»–æé†’æ–¹å¼' : 
                                        'å¯ä»¥è«‹æ±‚é€šçŸ¥æ¬Šé™'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'é€šçŸ¥æ¬Šé™æª¢æ¸¬',
                            category: 'permission',
                            success: false,
                            message: 'ä¸æ”¯æŒæ¡Œé¢é€šçŸ¥',
                            fallbackActivated: true,
                            userGuidance: 'ä½¿ç”¨æŒ¯å‹•å’ŒéŸ³æ•ˆä½œç‚ºæ›¿ä»£æé†’'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'é€šçŸ¥æ¬Šé™æª¢æ¸¬',
                        category: 'permission',
                        success: false,
                        message: 'é€šçŸ¥æ¬Šé™æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦åª’é«”æ¬Šé™
                try {
                    const supported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
                    if (supported) {
                        // ä¸å¯¦éš›è«‹æ±‚æ¬Šé™ï¼Œåªæª¢æ¸¬æ”¯æŒæ€§
                        this.testResults.push({
                            testName: 'åª’é«”æ¬Šé™æ”¯æŒ',
                            category: 'permission',
                            success: true,
                            message: 'æ”¯æŒåª’é«”æ¬Šé™è«‹æ±‚',
                            userGuidance: 'å¯ä»¥è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™é€²è¡ŒéŒ„éŸ³'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'åª’é«”æ¬Šé™æ”¯æŒ',
                            category: 'permission',
                            success: false,
                            message: 'ä¸æ”¯æŒåª’é«”æ¬Šé™',
                            fallbackActivated: true,
                            userGuidance: 'ç„¡æ³•ä½¿ç”¨éŒ„éŸ³åŠŸèƒ½'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'åª’é«”æ¬Šé™æ”¯æŒ',
                        category: 'permission',
                        success: false,
                        message: 'åª’é«”æ¬Šé™æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦ Wake Lock æ¬Šé™
                try {
                    const supported = 'wakeLock' in navigator;
                    this.testResults.push({
                        testName: 'Wake Lock æ¬Šé™æ”¯æŒ',
                        category: 'permission',
                        success: supported,
                        message: supported ? 'æ”¯æŒå±å¹•å¸¸äº®åŠŸèƒ½' : 'ä¸æ”¯æŒå±å¹•å¸¸äº®',
                        fallbackActivated: !supported,
                        userGuidance: supported ? 'å¯ä»¥ä¿æŒå±å¹•å¸¸äº®' : 'éœ€è¦æ‰‹å‹•ä¿æŒå±å¹•é–‹å•Ÿ'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'Wake Lock æ¬Šé™æ”¯æŒ',
                        category: 'permission',
                        success: false,
                        message: 'Wake Lock æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }
            }

            async testApiErrors() {
                console.log('æ¸¬è©¦ API éŒ¯èª¤è™•ç†...');

                // æ¸¬è©¦ Web Speech API
                try {
                    const supported = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
                    if (supported) {
                        const voices = speechSynthesis.getVoices();
                        this.testResults.push({
                            testName: 'Web Speech API',
                            category: 'api',
                            success: true,
                            message: `æ”¯æŒèªéŸ³åˆæˆï¼Œå¯ç”¨èªéŸ³: ${voices.length}å€‹`,
                            userGuidance: 'å¯ä»¥ä½¿ç”¨èªéŸ³æé†’åŠŸèƒ½'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'Web Speech API',
                            category: 'api',
                            success: false,
                            message: 'ä¸æ”¯æŒèªéŸ³åˆæˆ',
                            fallbackActivated: true,
                            userGuidance: 'ä½¿ç”¨æŒ¯å‹•å’ŒéŸ³æ•ˆä½œç‚ºæ›¿ä»£æé†’'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'Web Speech API',
                        category: 'api',
                        success: false,
                        message: 'Web Speech API æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦ Web Audio API
                try {
                    const supported = 'AudioContext' in window || 'webkitAudioContext' in window;
                    if (supported) {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        const context = new AudioContextClass();
                        await context.close();
                        
                        this.testResults.push({
                            testName: 'Web Audio API',
                            category: 'api',
                            success: true,
                            message: 'æ”¯æŒ Web Audio API',
                            userGuidance: 'å¯ä»¥æ’­æ”¾éŸ³æ•ˆæé†’'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'Web Audio API',
                            category: 'api',
                            success: false,
                            message: 'ä¸æ”¯æŒ Web Audio API',
                            fallbackActivated: true,
                            userGuidance: 'éŸ³æ•ˆåŠŸèƒ½å¯èƒ½å—é™'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'Web Audio API',
                        category: 'api',
                        success: false,
                        message: 'Web Audio API æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦ MediaRecorder API
                try {
                    const supported = 'MediaRecorder' in window;
                    if (supported) {
                        const supportedTypes = [
                            'audio/webm',
                            'audio/webm;codecs=opus',
                            'audio/ogg',
                            'audio/mp4'
                        ].filter(type => MediaRecorder.isTypeSupported(type));
                        
                        this.testResults.push({
                            testName: 'MediaRecorder API',
                            category: 'api',
                            success: supportedTypes.length > 0,
                            message: `æ”¯æŒ ${supportedTypes.length} ç¨®éŸ³é »æ ¼å¼`,
                            userGuidance: supportedTypes.length > 0 ? 'å¯ä»¥éŒ„è£½è‡ªå®šç¾©èªéŸ³' : 'éŒ„éŸ³åŠŸèƒ½å—é™'
                        });
                    } else {
                        this.testResults.push({
                            testName: 'MediaRecorder API',
                            category: 'api',
                            success: false,
                            message: 'ä¸æ”¯æŒ MediaRecorder API',
                            fallbackActivated: true,
                            userGuidance: 'ç„¡æ³•ä½¿ç”¨éŒ„éŸ³åŠŸèƒ½'
                        });
                    }
                } catch (error) {
                    this.testResults.push({
                        testName: 'MediaRecorder API',
                        category: 'api',
                        success: false,
                        message: 'MediaRecorder API æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }
            }

            async testRuntimeErrors() {
                console.log('æ¸¬è©¦é‹è¡Œæ™‚éŒ¯èª¤è™•ç†...');

                // æ¸¬è©¦å…¨å±€éŒ¯èª¤è™•ç†
                try {
                    const hasGlobalErrorHandler = 'onerror' in window;
                    const hasUnhandledRejectionHandler = 'onunhandledrejection' in window;
                    
                    this.testResults.push({
                        testName: 'å…¨å±€éŒ¯èª¤è™•ç†',
                        category: 'runtime',
                        success: hasGlobalErrorHandler && hasUnhandledRejectionHandler,
                        message: `å…¨å±€éŒ¯èª¤è™•ç†: ${hasGlobalErrorHandler ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}, Promise æ‹’çµ•è™•ç†: ${hasUnhandledRejectionHandler ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`,
                        userGuidance: 'æ‡‰ç”¨å…·æœ‰åŸºæœ¬çš„éŒ¯èª¤æ•ç²æ©Ÿåˆ¶'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'å…¨å±€éŒ¯èª¤è™•ç†',
                        category: 'runtime',
                        success: false,
                        message: 'å…¨å±€éŒ¯èª¤è™•ç†æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦å…§å­˜ç®¡ç†
                try {
                    const hasPerformanceAPI = 'performance' in window && 'memory' in window.performance;
                    let memoryInfo = null;
                    
                    if (hasPerformanceAPI) {
                        memoryInfo = window.performance.memory;
                    }
                    
                    this.testResults.push({
                        testName: 'å…§å­˜ç®¡ç†æª¢æ¸¬',
                        category: 'runtime',
                        success: hasPerformanceAPI,
                        message: hasPerformanceAPI ? 
                            `å·²ä½¿ç”¨: ${Math.round(memoryInfo.usedJSHeapSize / 1024 / 1024)}MB, ç¸½è¨ˆ: ${Math.round(memoryInfo.totalJSHeapSize / 1024 / 1024)}MB` :
                            'ç„¡æ³•ç²å–å…§å­˜ä¿¡æ¯',
                        userGuidance: hasPerformanceAPI ? 'å¯ä»¥ç›£æ§å…§å­˜ä½¿ç”¨' : 'å»ºè­°å®šæœŸé‡æ–°æ•´ç†é é¢'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'å…§å­˜ç®¡ç†æª¢æ¸¬',
                        category: 'runtime',
                        success: false,
                        message: 'å…§å­˜ç®¡ç†æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }

                // æ¸¬è©¦è³‡æºæ¸…ç†
                try {
                    const cleanupFeatures = [];
                    
                    if ('beforeunload' in window) cleanupFeatures.push('é é¢å¸è¼‰æ¸…ç†');
                    if ('visibilitychange' in document) cleanupFeatures.push('å¯è¦‹æ€§è®ŠåŒ–è™•ç†');
                    if ('pagehide' in window) cleanupFeatures.push('é é¢éš±è—è™•ç†');
                    
                    this.testResults.push({
                        testName: 'è³‡æºæ¸…ç†æ©Ÿåˆ¶',
                        category: 'runtime',
                        success: cleanupFeatures.length > 0,
                        message: `æ”¯æŒ: ${cleanupFeatures.join(', ')}`,
                        userGuidance: 'æ‡‰ç”¨æœƒè‡ªå‹•æ¸…ç†è³‡æº'
                    });
                } catch (error) {
                    this.testResults.push({
                        testName: 'è³‡æºæ¸…ç†æ©Ÿåˆ¶',
                        category: 'runtime',
                        success: false,
                        message: 'è³‡æºæ¸…ç†æª¢æ¸¬å¤±æ•—',
                        errorDetails: error.message
                    });
                }
            }

            generateTestReport() {
                const passed = this.testResults.filter(test => test.success).length;
                const total = this.testResults.length;
                const passRate = Math.round((passed / total) * 100);

                let overallStability;
                if (passRate >= 90) overallStability = 'excellent';
                else if (passRate >= 75) overallStability = 'good';
                else if (passRate >= 60) overallStability = 'fair';
                else overallStability = 'poor';

                const recommendations = this.generateRecommendations();
                const errorPatterns = this.analyzeErrorPatterns();

                return {
                    timestamp: Date.now(),
                    browserInfo: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        language: navigator.language
                    },
                    testResults: this.testResults,
                    overallStability,
                    recommendations,
                    errorPatterns,
                    summary: { total, passed, failed: total - passed, passRate }
                };
            }

            generateRecommendations() {
                const recommendations = [];
                const failed = this.testResults.filter(test => !test.success);
                const withFallback = this.testResults.filter(test => test.fallbackActivated).length;

                if (failed.length === 0) {
                    recommendations.push('æ‰€æœ‰éŒ¯èª¤è™•ç†æ©Ÿåˆ¶é‹è¡Œæ­£å¸¸ï¼Œæ‡‰ç”¨å…·æœ‰å„ªç§€çš„ç©©å®šæ€§');
                } else {
                    recommendations.push(`ç™¼ç¾ ${failed.length} å€‹éœ€è¦é—œæ³¨çš„å•é¡Œ`);
                }

                if (withFallback > 0) {
                    recommendations.push(`${withFallback} å€‹åŠŸèƒ½å•Ÿç”¨äº†é™ç´šæ–¹æ¡ˆï¼Œä¿è­‰åŸºæœ¬å¯ç”¨æ€§`);
                }

                const categories = ['storage', 'network', 'permission', 'api', 'runtime'];
                categories.forEach(category => {
                    const issues = failed.filter(test => test.category === category).length;
                    if (issues > 0) {
                        recommendations.push(`${this.getCategoryName(category)}åŠŸèƒ½éœ€è¦åŠ å¼·éŒ¯èª¤è™•ç†`);
                    }
                });

                return recommendations;
            }

            analyzeErrorPatterns() {
                const patterns = {};
                this.testResults.forEach(test => {
                    if (!test.success) {
                        patterns[test.category] = (patterns[test.category] || 0) + 1;
                    }
                });

                return Object.entries(patterns).map(([category, frequency]) => ({
                    category: this.getCategoryName(category),
                    frequency,
                    severity: frequency >= 3 ? 'high' : frequency >= 2 ? 'medium' : 'low'
                }));
            }

            getCategoryName(category) {
                const names = {
                    storage: 'å­˜å„²',
                    network: 'ç¶²çµ¡',
                    permission: 'æ¬Šé™',
                    api: 'API',
                    runtime: 'é‹è¡Œæ™‚'
                };
                return names[category] || category;
            }
        }

        // å…¨å±€è®Šé‡
        const errorTester = new ErrorHandlingTester();
        let isLoading = false;
        let currentReport = null;

        // å·¥å…·å‡½æ•¸
        function showError(message) {
            const alert = document.getElementById('errorAlert');
            alert.textContent = message;
            alert.style.display = 'block';
            setTimeout(() => alert.style.display = 'none', 5000);
        }

        function showSuccess(message) {
            const alert = document.getElementById('successAlert');
            alert.textContent = message;
            alert.style.display = 'block';
            setTimeout(() => alert.style.display = 'none', 3000);
        }

        function setLoading(loading) {
            isLoading = loading;
            const buttons = document.querySelectorAll('.btn');
            buttons.forEach(btn => btn.disabled = loading);
            
            const runBtn = document.getElementById('runTestBtn');
            if (loading) {
                runBtn.innerHTML = '<span class="loading"></span> æ¸¬è©¦é€²è¡Œä¸­...';
            } else {
                runBtn.textContent = 'é‹è¡Œå®Œæ•´éŒ¯èª¤æ¸¬è©¦';
            }
        }

        // é‹è¡Œå®Œæ•´æ¸¬è©¦
        async function runCompleteTest() {
            setLoading(true);
            
            try {
                const report = await errorTester.runCompleteErrorTest();
                currentReport = report;
                displayTestResults(report);
                showSuccess(`æ¸¬è©¦å®Œæˆï¼š${report.summary.passed}/${report.summary.total} é …é€šé`);
            } catch (error) {
                showError('æ¸¬è©¦åŸ·è¡Œå¤±æ•—: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        // é¡¯ç¤ºæ¸¬è©¦çµæœ
        function displayTestResults(report) {
            // é¡¯ç¤ºæ•´é«”çµ±è¨ˆ
            displayOverallStats(report.summary);
            
            // é¡¯ç¤ºç©©å®šæ€§æŒ‡æ¨™
            displayStabilityIndicator(report.overallStability);
            
            // é¡¯ç¤ºæ¸¬è©¦åˆ†é¡çµæœ
            displayTestCategories(report.testResults);
            
            // é¡¯ç¤ºç€è¦½å™¨ä¿¡æ¯
            displayBrowserInfo(report.browserInfo);
            
            // é¡¯ç¤ºå»ºè­°
            displayRecommendations(report.recommendations);
            
            // é¡¯ç¤ºéŒ¯èª¤æ¨¡å¼
            displayErrorPatterns(report.errorPatterns);
            
            // é¡¯ç¤ºçµæœå€åŸŸ
            document.getElementById('testResults').style.display = 'block';
            document.getElementById('browserInfo').style.display = 'block';
            document.getElementById('recommendations').style.display = 'block';
            document.getElementById('errorPatterns').style.display = 'block';
        }

        function displayOverallStats(summary) {
            const container = document.getElementById('overallStats');
            container.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${summary.total}</div>
                    <div class="stat-label">ç¸½æ¸¬è©¦æ•¸</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.passed}</div>
                    <div class="stat-label">é€šéæ•¸</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.failed}</div>
                    <div class="stat-label">å¤±æ•—æ•¸</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${summary.passRate}%</div>
                    <div class="stat-label">é€šéç‡</div>
                </div>
            `;
        }

        function displayStabilityIndicator(stability) {
            const container = document.getElementById('stabilityIndicator');
            const stabilityText = {
                excellent: 'å„ªç§€',
                good: 'è‰¯å¥½',
                fair: 'ä¸€èˆ¬',
                poor: 'è¼ƒå·®'
            };
            
            container.innerHTML = `
                <h4>æ•´é«”ç©©å®šæ€§è©•ç´š</h4>
                <span class="stability-indicator stability-${stability}">
                    ${stabilityText[stability]}
                </span>
            `;
        }

        function displayTestCategories(testResults) {
            const container = document.getElementById('testCategories');
            const categories = ['storage', 'network', 'permission', 'api', 'runtime'];
            
            let html = '';
            categories.forEach(category => {
                const categoryTests = testResults.filter(test => test.category === category);
                if (categoryTests.length === 0) return;
                
                const categoryName = errorTester.getCategoryName(category);
                const passed = categoryTests.filter(test => test.success).length;
                
                html += `
                    <div class="test-category ${category}">
                        <h4>${categoryName}æ¸¬è©¦ (${passed}/${categoryTests.length} é€šé)</h4>
                        ${categoryTests.map(test => `
                            <div class="test-item ${test.success ? 'passed' : 'failed'}">
                                <div class="test-name">${test.testName}</div>
                                <div class="test-message">${test.message}</div>
                                ${test.userGuidance ? `<div class="test-guidance">ğŸ’¡ ${test.userGuidance}</div>` : ''}
                                ${test.errorDetails ? `<div class="test-details">éŒ¯èª¤è©³æƒ…: ${test.errorDetails}</div>` : ''}
                                ${test.fallbackActivated ? '<span class="badge badge-warning">é™ç´šæ–¹æ¡ˆå·²å•Ÿç”¨</span>' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function displayBrowserInfo(browserInfo) {
            const container = document.getElementById('browserDetails');
            container.innerHTML = `
                <p><strong>ç”¨æˆ¶ä»£ç†:</strong> ${browserInfo.userAgent}</p>
                <p><strong>å¹³å°:</strong> ${browserInfo.platform}</p>
                <p><strong>èªè¨€:</strong> ${browserInfo.language}</p>
            `;
        }

        function displayRecommendations(recommendations) {
            const container = document.getElementById('recommendationsList');
            container.innerHTML = recommendations.map(rec => `<li>${rec}</li>`).join('');
        }

        function displayErrorPatterns(patterns) {
            const container = document.getElementById('patternsContainer');
            
            if (patterns.length === 0) {
                container.innerHTML = '<p>æ²’æœ‰ç™¼ç¾é¡¯è‘—çš„éŒ¯èª¤æ¨¡å¼ âœ…</p>';
                return;
            }
            
            container.innerHTML = patterns.map(pattern => `
                <div class="pattern-item severity-${pattern.severity}">
                    <span>${pattern.category}é¡éŒ¯èª¤: ${pattern.frequency}å€‹</span>
                    <span class="badge badge-${pattern.severity === 'high' ? 'danger' : pattern.severity === 'medium' ? 'warning' : 'success'}">
                        ${pattern.severity === 'high' ? 'é«˜' : pattern.severity === 'medium' ? 'ä¸­' : 'ä½'}åš´é‡æ€§
                    </span>
                </div>
            `).join('');
        }

        // æ¸…é™¤çµæœ
        function clearResults() {
            document.getElementById('testResults').style.display = 'none';
            document.getElementById('browserInfo').style.display = 'none';
            document.getElementById('recommendations').style.display = 'none';
            document.getElementById('errorPatterns').style.display = 'none';
            currentReport = null;
        }

        // äº‹ä»¶ç›£è½å™¨
        document.getElementById('runTestBtn').addEventListener('click', runCompleteTest);
        document.getElementById('testStorageBtn').addEventListener('click', async () => {
            setLoading(true);
            try {
                await errorTester.testStorageErrors();
                showSuccess('å­˜å„²éŒ¯èª¤æ¸¬è©¦å®Œæˆ');
            } catch (error) {
                showError('å­˜å„²æ¸¬è©¦å¤±æ•—: ' + error.message);
            } finally {
                setLoading(false);
            }
        });
        document.getElementById('testNetworkBtn').addEventListener('click', async () => {
            setLoading(true);
            try {
                await errorTester.testNetworkErrors();
                showSuccess('ç¶²çµ¡éŒ¯èª¤æ¸¬è©¦å®Œæˆ');
            } catch (error) {
                showError('ç¶²çµ¡æ¸¬è©¦å¤±æ•—: ' + error.message);
            } finally {
                setLoading(false);
            }
        });
        document.getElementById('testPermissionBtn').addEventListener('click', async () => {
            setLoading(true);
            try {
                await errorTester.testPermissionErrors();
                showSuccess('æ¬Šé™éŒ¯èª¤æ¸¬è©¦å®Œæˆ');
            } catch (error) {
                showError('æ¬Šé™æ¸¬è©¦å¤±æ•—: ' + error.message);
            } finally {
                setLoading(false);
            }
        });
        document.getElementById('testApiBtn').addEventListener('click', async () => {
            setLoading(true);
            try {
                await errorTester.testApiErrors();
                showSuccess('APIéŒ¯èª¤æ¸¬è©¦å®Œæˆ');
            } catch (error) {
                showError('APIæ¸¬è©¦å¤±æ•—: ' + error.message);
            } finally {
                setLoading(false);
            }
        });
        document.getElementById('clearBtn').addEventListener('click', clearResults);

        // é é¢åŠ è¼‰å®Œæˆå¾Œè‡ªå‹•é‹è¡Œæ¸¬è©¦
        window.addEventListener('load', () => {
            setTimeout(runCompleteTest, 1000);
        });
    </script>
</body>
</html>


