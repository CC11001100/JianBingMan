<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç…é¤…ä¿  - æ•¸æ“šå‚™ä»½å’Œæ¢å¾©æ¸¬è©¦</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #ff6b35;
            transition: all 0.3s ease;
        }

        .test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .test-card h3 {
            color: #ff6b35;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .test-card p {
            color: #666;
            margin-bottom: 15px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #ff6b35;
            color: white;
        }

        .btn-primary:hover {
            background: #e55722;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .result-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #dee2e6;
        }

        .result-panel h4 {
            color: #495057;
            margin-bottom: 15px;
        }

        .result-content {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
        }

        .status-panel {
            background: #e3f2fd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-label {
            font-weight: 500;
            color: #333;
        }

        .status-value {
            color: #666;
            font-family: 'Courier New', monospace;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            width: 0%;
            transition: width 0.3s ease;
        }

        .hidden {
            display: none;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .alert {
            padding: 12px 16px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }

        .alert-success {
            background: #d1edff;
            color: #0c5460;
            border: 1px solid #b3d7ff;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .file-input {
            margin-bottom: 15px;
        }

        .file-input input[type="file"] {
            padding: 8px;
            border: 2px dashed #dee2e6;
            border-radius: 6px;
            width: 100%;
            background: #f8f9fa;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .test-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—„ï¸ æ•¸æ“šå‚™ä»½å’Œæ¢å¾©æ¸¬è©¦</h1>
            <p>æ¸¬è©¦ç…é¤…ä¿ æ‡‰ç”¨çš„å®Œæ•´æ•¸æ“šå‚™ä»½ã€å°å‡ºã€å°å…¥å’Œæ¢å¾©åŠŸèƒ½</p>
        </div>

        <div class="content">
            <!-- ç•¶å‰ç‹€æ…‹é¢æ¿ -->
            <div class="status-panel">
                <h4>ğŸ“Š ç•¶å‰æ•¸æ“šç‹€æ…‹</h4>
                <div class="status-item">
                    <span class="status-label">æ•¸æ“šé¡å‹ï¼š</span>
                    <span class="status-value" id="dataTypes">è¼‰å…¥ä¸­...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">ä¼°ç®—å¤§å°ï¼š</span>
                    <span class="status-value" id="dataSize">è¼‰å…¥ä¸­...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">æ­·å²è¨˜éŒ„ï¼š</span>
                    <span class="status-value" id="historyCount">è¼‰å…¥ä¸­...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">è‡ªå®šç¾©èªéŸ³ï¼š</span>
                    <span class="status-value" id="voiceCount">è¼‰å…¥ä¸­...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">æœ€å¾Œæ›´æ–°ï¼š</span>
                    <span class="status-value" id="lastUpdated">è¼‰å…¥ä¸­...</span>
                </div>
            </div>

            <!-- æ¸¬è©¦åŠŸèƒ½ç¶²æ ¼ -->
            <div class="test-grid">
                <!-- å‰µå»ºå‚™ä»½ -->
                <div class="test-card">
                    <h3>ğŸ’¾ å‰µå»ºå‚™ä»½</h3>
                    <p>å‰µå»ºåŒ…å«æ‰€æœ‰ç”¨æˆ¶æ•¸æ“šçš„å®Œæ•´å‚™ä»½ï¼ŒåŒ…æ‹¬è¨­ç½®ã€æ ¡æº–æ•¸æ“šã€æ­·å²è¨˜éŒ„å’Œè‡ªå®šç¾©èªéŸ³ã€‚</p>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="createBackup()">
                            ğŸ“¦ å‰µå»ºå‚™ä»½
                        </button>
                    </div>
                </div>

                <!-- å°å‡ºå‚™ä»½ -->
                <div class="test-card">
                    <h3>â¬‡ï¸ å°å‡ºå‚™ä»½</h3>
                    <p>å°‡å‚™ä»½æ•¸æ“šå°å‡ºç‚ºæ–‡ä»¶ï¼Œæ”¯æŒ JSON å’ŒåŠ å¯†æ ¼å¼ã€‚</p>
                    <div class="button-group">
                        <button class="btn btn-success" onclick="exportBackup('json')">
                            ğŸ“„ JSON æ ¼å¼
                        </button>
                        <button class="btn btn-secondary" onclick="exportBackup('encrypted')">
                            ğŸ”’ åŠ å¯†æ ¼å¼
                        </button>
                    </div>
                </div>

                <!-- å°å…¥æ¢å¾© -->
                <div class="test-card">
                    <h3>â¬†ï¸ å°å…¥æ¢å¾©</h3>
                    <p>å¾å‚™ä»½æ–‡ä»¶æ¢å¾©æ•¸æ“šï¼Œæ”¯æŒæ•¸æ“šé©—è­‰å’Œå®Œæ•´æ€§æª¢æŸ¥ã€‚</p>
                    <div class="file-input">
                        <input type="file" id="backupFile" accept=".json,.bak" onchange="handleFileSelect(this)">
                    </div>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="importBackup()" disabled id="importBtn">
                            ğŸ”„ å°å…¥æ•¸æ“š
                        </button>
                    </div>
                </div>

                <!-- æ•¸æ“šé©—è­‰ -->
                <div class="test-card">
                    <h3>âœ… æ•¸æ“šé©—è­‰</h3>
                    <p>é©—è­‰å‚™ä»½æ–‡ä»¶çš„å®Œæ•´æ€§ã€æ ¼å¼å…¼å®¹æ€§å’Œæ•¸æ“šæœ‰æ•ˆæ€§ã€‚</p>
                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="validateCurrentData()">
                            ğŸ” é©—è­‰ç•¶å‰æ•¸æ“š
                        </button>
                        <button class="btn btn-secondary" onclick="runCompatibilityTest()">
                            ğŸ§ª å…¼å®¹æ€§æ¸¬è©¦
                        </button>
                    </div>
                </div>

                <!-- æ•¸æ“šçµ±è¨ˆ -->
                <div class="test-card">
                    <h3>ğŸ“ˆ æ•¸æ“šçµ±è¨ˆ</h3>
                    <p>ç²å–è©³ç´°çš„æ•¸æ“šçµ±è¨ˆä¿¡æ¯å’Œå­˜å„²ä½¿ç”¨æƒ…æ³ã€‚</p>
                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="getDetailedStats()">
                            ğŸ“Š è©³ç´°çµ±è¨ˆ
                        </button>
                        <button class="btn btn-secondary" onclick="refreshStats()">
                            ğŸ”„ åˆ·æ–°çµ±è¨ˆ
                        </button>
                    </div>
                </div>

                <!-- å±éšªæ“ä½œ -->
                <div class="test-card">
                    <h3>âš ï¸ å±éšªæ“ä½œ</h3>
                    <p>æ¸…é™¤æ‰€æœ‰æ•¸æ“šã€‚æ­¤æ“ä½œä¸å¯æ’¤éŠ·ï¼Œå»ºè­°åœ¨æ“ä½œå‰å…ˆå‰µå»ºå‚™ä»½ã€‚</p>
                    <div class="button-group">
                        <button class="btn btn-danger" onclick="clearAllData()">
                            ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ•¸æ“š
                        </button>
                    </div>
                </div>
            </div>

            <!-- é€²åº¦æ¢ -->
            <div class="progress-bar hidden" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <!-- çµæœé¡¯ç¤ºé¢æ¿ -->
            <div class="result-panel">
                <h4>ğŸ“ æ¸¬è©¦çµæœ</h4>
                <div class="result-content" id="resultContent">
                    æº–å‚™åŸ·è¡Œæ•¸æ“šå‚™ä»½å’Œæ¢å¾©æ¸¬è©¦...
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¨¡æ“¬ IndexedDB æ•¸æ“šç®¡ç†
        class MockDataBackupManager {
            constructor() {
                this.currentData = {
                    settings: {
                        flipInterval: 20,
                        customPrompt: 'è©²ç¿»é¢äº†ï¼',
                        volume: 0.8,
                        speechRate: 1.0,
                        speechPitch: 1.0,
                        voiceType: 'auto',
                        vibrationEnabled: true,
                        speechEnabled: true,
                        soundEffectsEnabled: true,
                        soundEffectType: 'chime',
                        notificationEnabled: true,
                        lastUsed: Date.now()
                    },
                    calibration: {
                        calibratedTime: 18,
                        calibratedAt: Date.now() - 86400000
                    },
                    history: this.generateMockHistory(15),
                    customVoices: this.generateMockVoices(3)
                }
                this.lastBackup = null
                this.init()
            }

            generateMockHistory(count) {
                const history = []
                for (let i = 0; i < count; i++) {
                    history.push({
                        id: i + 1,
                        duration: 15 + Math.floor(Math.random() * 20),
                        wasCalibration: Math.random() < 0.1,
                        timestamp: Date.now() - (i * 86400000)
                    })
                }
                return history
            }

            generateMockVoices(count) {
                const voices = []
                for (let i = 0; i < count; i++) {
                    voices.push({
                        id: `voice_${i + 1}`,
                        name: `è‡ªå®šç¾©èªéŸ³ ${i + 1}`,
                        audioData: btoa(`mock_audio_data_${i + 1}`),
                        duration: 2 + Math.random() * 3,
                        createdAt: Date.now() - (i * 3600000),
                        lastUsed: Date.now() - (i * 86400000)
                    })
                }
                return voices
            }

            init() {
                this.updateStatusPanel()
            }

            updateStatusPanel() {
                const dataTypes = Object.keys(this.currentData).filter(key => 
                    this.currentData[key] !== null && 
                    (!Array.isArray(this.currentData[key]) || this.currentData[key].length > 0)
                ).length

                const estimatedSize = JSON.stringify(this.currentData).length

                document.getElementById('dataTypes').textContent = `${dataTypes} ç¨®`
                document.getElementById('dataSize').textContent = this.formatFileSize(estimatedSize)
                document.getElementById('historyCount').textContent = `${this.currentData.history.length} è¨˜éŒ„`
                document.getElementById('voiceCount').textContent = `${this.currentData.customVoices.length} å€‹`
                document.getElementById('lastUpdated').textContent = new Date().toLocaleString('zh-TW')
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B'
                const k = 1024
                const sizes = ['B', 'KB', 'MB', 'GB']
                const i = Math.floor(Math.log(bytes) / Math.log(k))
                return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`
            }

            async createFullBackup() {
                await this.simulateDelay(1000, 'æ­£åœ¨æ”¶é›†æ•¸æ“š...')
                
                const backup = {
                    version: '1.0.0',
                    timestamp: Date.now(),
                    deviceInfo: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        language: navigator.language,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    },
                    data: JSON.parse(JSON.stringify(this.currentData)),
                    checksum: ''
                }

                backup.checksum = await this.calculateChecksum(backup)
                this.lastBackup = backup

                return backup
            }

            async exportBackupToFile(format = 'json') {
                const backup = this.lastBackup || await this.createFullBackup()
                
                let content, filename, mimeType

                if (format === 'json') {
                    content = JSON.stringify(backup, null, 2)
                    filename = `pancake-timer-backup-${new Date().toISOString().split('T')[0]}.json`
                    mimeType = 'application/json'
                } else {
                    content = btoa(JSON.stringify(backup))
                    filename = `pancake-timer-backup-${new Date().toISOString().split('T')[0]}.bak`
                    mimeType = 'application/octet-stream'
                }

                await this.simulateDelay(800, `æ­£åœ¨å°å‡º ${format.toUpperCase()} æ ¼å¼...`)

                this.downloadFile(content, filename, mimeType)
                return { filename, size: content.length }
            }

            async validateImportData(content) {
                await this.simulateDelay(600, 'æ­£åœ¨é©—è­‰æ•¸æ“š...')

                const result = {
                    isValid: false,
                    version: '',
                    errors: [],
                    warnings: [],
                    dataTypes: [],
                    totalSize: content.length,
                    recordCounts: { settings: 0, calibration: 0, history: 0, customVoices: 0 }
                }

                try {
                    let data
                    try {
                        data = JSON.parse(content)
                    } catch {
                        data = JSON.parse(atob(content))
                    }

                    result.version = data.version || 'æœªçŸ¥'
                    
                    if (!data.version) {
                        result.errors.push('ç¼ºå°‘ç‰ˆæœ¬ä¿¡æ¯')
                    }

                    if (!data.timestamp) {
                        result.errors.push('ç¼ºå°‘æ™‚é–“æˆ³')
                    } else if (data.timestamp > Date.now()) {
                        result.warnings.push('å‚™ä»½æ™‚é–“æ™šæ–¼ç•¶å‰æ™‚é–“')
                    }

                    if (!data.data) {
                        result.errors.push('ç¼ºå°‘æ•¸æ“šå…§å®¹')
                        return result
                    }

                    // é©—è­‰å„æ•¸æ“šé¡å‹
                    if (data.data.settings) {
                        result.dataTypes.push('settings')
                        result.recordCounts.settings = 1
                    }

                    if (data.data.calibration) {
                        result.dataTypes.push('calibration')
                        result.recordCounts.calibration = 1
                    }

                    if (data.data.history && Array.isArray(data.data.history)) {
                        result.dataTypes.push('history')
                        result.recordCounts.history = data.data.history.length
                    }

                    if (data.data.customVoices && Array.isArray(data.data.customVoices)) {
                        result.dataTypes.push('customVoices')
                        result.recordCounts.customVoices = data.data.customVoices.length
                    }

                    if (data.checksum) {
                        const expectedChecksum = await this.calculateChecksum({ ...data, checksum: '' })
                        if (expectedChecksum !== data.checksum) {
                            result.warnings.push('æ ¡é©—å’Œä¸åŒ¹é…ï¼Œæ•¸æ“šå¯èƒ½å·²æå£')
                        }
                    } else {
                        result.warnings.push('ç¼ºå°‘æ ¡é©—å’Œ')
                    }

                    result.isValid = result.errors.length === 0 && result.dataTypes.length > 0

                } catch (error) {
                    result.errors.push(`è§£ææ•¸æ“šå¤±æ•—: ${error.message}`)
                }

                return result
            }

            async importAndRestoreData(content, options = {}) {
                const validation = await this.validateImportData(content)
                
                if (!validation.isValid) {
                    throw new Error(`å°å…¥æ•¸æ“šç„¡æ•ˆ: ${validation.errors.join(', ')}`)
                }

                await this.simulateDelay(1200, 'æ­£åœ¨æ¢å¾©æ•¸æ“š...')

                let data
                try {
                    data = JSON.parse(content)
                } catch {
                    data = JSON.parse(atob(content))
                }

                if (options.overwrite || !this.currentData.settings) {
                    this.currentData.settings = data.data.settings
                }

                if (options.overwrite || !this.currentData.calibration) {
                    this.currentData.calibration = data.data.calibration
                }

                if (options.mergeHistory && data.data.history) {
                    this.currentData.history = [...this.currentData.history, ...data.data.history]
                } else if (options.overwrite && data.data.history) {
                    this.currentData.history = data.data.history
                }

                if (options.preserveCustomVoices && data.data.customVoices) {
                    this.currentData.customVoices = [...this.currentData.customVoices, ...data.data.customVoices]
                } else if (options.overwrite && data.data.customVoices) {
                    this.currentData.customVoices = data.data.customVoices
                }

                this.updateStatusPanel()
                return validation
            }

            async clearAllData() {
                await this.simulateDelay(500, 'æ­£åœ¨æ¸…é™¤æ•¸æ“š...')
                
                this.currentData = {
                    settings: null,
                    calibration: null,
                    history: [],
                    customVoices: []
                }

                this.lastBackup = null
                this.updateStatusPanel()
            }

            async getDetailedStats() {
                await this.simulateDelay(300, 'æ­£åœ¨è¨ˆç®—çµ±è¨ˆ...')

                const stats = {
                    totalRecords: 0,
                    dataTypes: 0,
                    storageUsage: JSON.stringify(this.currentData).length,
                    breakdown: {}
                }

                Object.keys(this.currentData).forEach(key => {
                    const data = this.currentData[key]
                    if (data !== null) {
                        stats.dataTypes++
                        if (Array.isArray(data)) {
                            stats.totalRecords += data.length
                            stats.breakdown[key] = `${data.length} è¨˜éŒ„`
                        } else {
                            stats.totalRecords += 1
                            stats.breakdown[key] = '1 é …'
                        }
                    } else {
                        stats.breakdown[key] = 'ç„¡æ•¸æ“š'
                    }
                })

                return stats
            }

            async calculateChecksum(data) {
                await this.simulateDelay(100)
                const str = JSON.stringify(data)
                return btoa(str).slice(0, 32)
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType })
                const url = URL.createObjectURL(blob)
                const a = document.createElement('a')
                a.href = url
                a.download = filename
                a.style.display = 'none'
                document.body.appendChild(a)
                a.click()
                document.body.removeChild(a)
                URL.revokeObjectURL(url)
            }

            async simulateDelay(ms, message = 'è™•ç†ä¸­...') {
                if (message) {
                    this.updateProgress(0, message)
                    this.showProgress()
                }

                for (let i = 0; i <= 100; i += 10) {
                    await new Promise(resolve => setTimeout(resolve, ms / 10))
                    this.updateProgress(i, message)
                }

                this.hideProgress()
            }

            showProgress() {
                document.getElementById('progressBar').classList.remove('hidden')
            }

            hideProgress() {
                document.getElementById('progressBar').classList.add('hidden')
            }

            updateProgress(percent, message) {
                document.getElementById('progressFill').style.width = `${percent}%`
            }
        }

        // å…¨å±€è®Šé‡
        let dataManager
        let selectedFile = null

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            dataManager = new MockDataBackupManager()
            log('ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼Œæº–å‚™é€²è¡Œæ•¸æ“šå‚™ä»½å’Œæ¢å¾©æ¸¬è©¦')
        })

        // æ—¥èªŒå‡½æ•¸
        function log(message, type = 'info') {
            const resultContent = document.getElementById('resultContent')
            const timestamp = new Date().toLocaleTimeString('zh-TW')
            const icon = type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸'
            
            resultContent.innerHTML += `
                <div style="margin-bottom: 8px; padding: 8px; border-left: 3px solid ${getTypeColor(type)}; background: ${getTypeBg(type)}">
                    <strong>[${timestamp}]</strong> ${icon} ${message}
                </div>
            `
            resultContent.scrollTop = resultContent.scrollHeight
        }

        function getTypeColor(type) {
            switch (type) {
                case 'success': return '#28a745'
                case 'error': return '#dc3545'
                case 'warning': return '#ffc107'
                default: return '#17a2b8'
            }
        }

        function getTypeBg(type) {
            switch (type) {
                case 'success': return '#d1edff'
                case 'error': return '#f8d7da'
                case 'warning': return '#fff3cd'
                default: return '#d1ecf1'
            }
        }

        // æ¸¬è©¦å‡½æ•¸
        async function createBackup() {
            try {
                log('é–‹å§‹å‰µå»ºæ•¸æ“šå‚™ä»½...')
                const backup = await dataManager.createFullBackup()
                
                log(`âœ… å‚™ä»½å‰µå»ºæˆåŠŸï¼`, 'success')
                log(`ç‰ˆæœ¬ï¼š${backup.version}`)
                log(`æ™‚é–“æˆ³ï¼š${new Date(backup.timestamp).toLocaleString('zh-TW')}`)
                log(`æ•¸æ“šé¡å‹ï¼š${Object.keys(backup.data).filter(key => backup.data[key] !== null).length} ç¨®`)
                log(`æ ¡é©—å’Œï¼š${backup.checksum}`)
                
            } catch (error) {
                log(`âŒ å‰µå»ºå‚™ä»½å¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function exportBackup(format) {
            try {
                log(`é–‹å§‹å°å‡º ${format.toUpperCase()} æ ¼å¼å‚™ä»½...`)
                const result = await dataManager.exportBackupToFile(format)
                
                log(`âœ… å‚™ä»½å°å‡ºæˆåŠŸï¼`, 'success')
                log(`æ–‡ä»¶åï¼š${result.filename}`)
                log(`æ–‡ä»¶å¤§å°ï¼š${dataManager.formatFileSize(result.size)}`)
                log(`æ ¼å¼ï¼š${format.toUpperCase()}`)
                
            } catch (error) {
                log(`âŒ å°å‡ºå‚™ä»½å¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function handleFileSelect(input) {
            const file = input.files[0]
            if (!file) return

            selectedFile = file
            document.getElementById('importBtn').disabled = false
            
            log(`ğŸ“ å·²é¸æ“‡æ–‡ä»¶ï¼š${file.name}`)
            log(`æ–‡ä»¶å¤§å°ï¼š${dataManager.formatFileSize(file.size)}`)
            log(`æ–‡ä»¶é¡å‹ï¼š${file.type || 'æœªçŸ¥'}`)

            // é è¦½é©—è­‰
            try {
                const content = await readFileContent(file)
                const validation = await dataManager.validateImportData(content)
                
                if (validation.isValid) {
                    log(`âœ… æ–‡ä»¶é©—è­‰é€šé`, 'success')
                    log(`ç‰ˆæœ¬ï¼š${validation.version}`)
                    log(`æ•¸æ“šé¡å‹ï¼š${validation.dataTypes.join(', ')}`)
                } else {
                    log(`âš ï¸ æ–‡ä»¶é©—è­‰è­¦å‘Š`, 'warning')
                    validation.errors.forEach(error => log(`éŒ¯èª¤ï¼š${error}`, 'error'))
                    validation.warnings.forEach(warning => log(`è­¦å‘Šï¼š${warning}`, 'warning'))
                }
            } catch (error) {
                log(`âŒ æ–‡ä»¶é è¦½å¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function importBackup() {
            if (!selectedFile) {
                log('âŒ è«‹å…ˆé¸æ“‡å‚™ä»½æ–‡ä»¶', 'error')
                return
            }

            try {
                log('é–‹å§‹å°å…¥æ•¸æ“š...')
                const content = await readFileContent(selectedFile)
                
                const options = {
                    overwrite: confirm('æ˜¯å¦è¦†è“‹ç¾æœ‰æ•¸æ“šï¼Ÿ'),
                    mergeHistory: confirm('æ˜¯å¦åˆä½µæ­·å²è¨˜éŒ„ï¼Ÿ'),
                    preserveCustomVoices: confirm('æ˜¯å¦ä¿ç•™ç¾æœ‰è‡ªå®šç¾©èªéŸ³ï¼Ÿ')
                }

                const result = await dataManager.importAndRestoreData(content, options)
                
                log(`âœ… æ•¸æ“šå°å…¥æˆåŠŸï¼`, 'success')
                log(`æ¢å¾©çš„æ•¸æ“šé¡å‹ï¼š${result.dataTypes.join(', ')}`)
                log(`è¨­ç½®ï¼š${result.recordCounts.settings} é …`)
                log(`æ ¡æº–ï¼š${result.recordCounts.calibration} é …`)
                log(`æ­·å²ï¼š${result.recordCounts.history} è¨˜éŒ„`)
                log(`èªéŸ³ï¼š${result.recordCounts.customVoices} å€‹`)
                
                selectedFile = null
                document.getElementById('importBtn').disabled = true
                document.getElementById('backupFile').value = ''
                
            } catch (error) {
                log(`âŒ å°å…¥æ•¸æ“šå¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function validateCurrentData() {
            try {
                log('é–‹å§‹é©—è­‰ç•¶å‰æ•¸æ“š...')
                const backup = await dataManager.createFullBackup()
                const content = JSON.stringify(backup)
                const validation = await dataManager.validateImportData(content)
                
                if (validation.isValid) {
                    log(`âœ… ç•¶å‰æ•¸æ“šé©—è­‰é€šé`, 'success')
                } else {
                    log(`âŒ ç•¶å‰æ•¸æ“šé©—è­‰å¤±æ•—`, 'error')
                    validation.errors.forEach(error => log(`éŒ¯èª¤ï¼š${error}`, 'error'))
                }
                
                log(`æ•¸æ“šå®Œæ•´æ€§ï¼š${validation.isValid ? 'å®Œæ•´' : 'ä¸å®Œæ•´'}`)
                log(`æ•¸æ“šé¡å‹ï¼š${validation.dataTypes.length} ç¨®`)
                log(`æ–‡ä»¶å¤§å°ï¼š${dataManager.formatFileSize(validation.totalSize)}`)
                
            } catch (error) {
                log(`âŒ é©—è­‰å¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function runCompatibilityTest() {
            try {
                log('é–‹å§‹é‹è¡Œå…¼å®¹æ€§æ¸¬è©¦...')
                
                // æ¸¬è©¦ä¸åŒæ ¼å¼
                const formats = ['json', 'encrypted']
                for (const format of formats) {
                    log(`æ¸¬è©¦ ${format.toUpperCase()} æ ¼å¼å…¼å®¹æ€§...`)
                    const backup = await dataManager.createFullBackup()
                    
                    let content
                    if (format === 'json') {
                        content = JSON.stringify(backup)
                    } else {
                        content = btoa(JSON.stringify(backup))
                    }
                    
                    const validation = await dataManager.validateImportData(content)
                    
                    if (validation.isValid) {
                        log(`âœ… ${format.toUpperCase()} æ ¼å¼å…¼å®¹`, 'success')
                    } else {
                        log(`âŒ ${format.toUpperCase()} æ ¼å¼ä¸å…¼å®¹`, 'error')
                    }
                }
                
                log('âœ… å…¼å®¹æ€§æ¸¬è©¦å®Œæˆ', 'success')
                
            } catch (error) {
                log(`âŒ å…¼å®¹æ€§æ¸¬è©¦å¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function getDetailedStats() {
            try {
                log('ç²å–è©³ç´°çµ±è¨ˆä¿¡æ¯...')
                const stats = await dataManager.getDetailedStats()
                
                log(`ğŸ“Š è©³ç´°çµ±è¨ˆä¿¡æ¯ï¼š`, 'success')
                log(`ç¸½è¨˜éŒ„æ•¸ï¼š${stats.totalRecords}`)
                log(`æ•¸æ“šé¡å‹ï¼š${stats.dataTypes} ç¨®`)
                log(`å­˜å„²ä½¿ç”¨ï¼š${dataManager.formatFileSize(stats.storageUsage)}`)
                
                Object.keys(stats.breakdown).forEach(key => {
                    log(`${key}ï¼š${stats.breakdown[key]}`)
                })
                
            } catch (error) {
                log(`âŒ ç²å–çµ±è¨ˆå¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function refreshStats() {
            try {
                log('åˆ·æ–°çµ±è¨ˆä¿¡æ¯...')
                dataManager.updateStatusPanel()
                log('âœ… çµ±è¨ˆä¿¡æ¯å·²åˆ·æ–°', 'success')
            } catch (error) {
                log(`âŒ åˆ·æ–°çµ±è¨ˆå¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        async function clearAllData() {
            const confirmed = confirm('âš ï¸ ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ•¸æ“šå—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤éŠ·ï¼å»ºè­°åœ¨æ¸…é™¤å‰å…ˆå‰µå»ºå‚™ä»½ã€‚')
            if (!confirmed) {
                log('ç”¨æˆ¶å–æ¶ˆäº†æ¸…é™¤æ“ä½œ')
                return
            }

            try {
                log('é–‹å§‹æ¸…é™¤æ‰€æœ‰æ•¸æ“š...')
                await dataManager.clearAllData()
                log('âœ… æ‰€æœ‰æ•¸æ“šå·²æ¸…é™¤', 'success')
                log('ç³»çµ±å·²é‡ç½®ç‚ºåˆå§‹ç‹€æ…‹')
                
            } catch (error) {
                log(`âŒ æ¸…é™¤æ•¸æ“šå¤±æ•—ï¼š${error.message}`, 'error')
            }
        }

        // è¼”åŠ©å‡½æ•¸
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader()
                reader.onload = e => resolve(e.target.result)
                reader.onerror = () => reject(new Error('è®€å–æ–‡ä»¶å¤±æ•—'))
                reader.readAsText(file)
            })
        }
    </script>
</body>
</html>


